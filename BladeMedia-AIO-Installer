#!/usr/bin/env bash
set -euo pipefail

print_banner() {
  printf '\n\033[1;36m'
  printf '==============================================\n'
  printf '      üó°Ô∏è  BladeMedia COMPLETE Setup  v3.0     \n'
  printf '   Docker Stack + Auto-Organizer Service     \n'
  printf '==============================================\n'
  printf '\033[0m\n'
}

main() {
  print_banner

  # === STEP 1: Ask for BladeMedia root ===
  local ROOT
  read -rp "Enter BladeMedia root (e.g. /srv/blademedia): " ROOT

  if [[ -z "$ROOT" || "$ROOT" != /* ]]; then
    echo "Error: Root must be an absolute path (start with /)" >&2
    exit 1
  fi

  mkdir -p "$ROOT"
  cd "$ROOT"
  echo "Using BladeMedia root: $ROOT"

  # === STEP 2: Optional Discord webhook ===
  local WEBHOOK
  read -rp "Discord webhook URL (press Enter to skip): " WEBHOOK
  WEBHOOK="${WEBHOOK:-}"

  # === STEP 3: Install Docker (if needed) ===
  echo
  echo "=== Checking/Installing Docker ==="
  if ! command -v docker >/dev/null 2>&1; then
    echo "Docker not found, installing via convenience script..."
    curl -fsSL https://get.docker.com -o get-docker.sh
    sh get-docker.sh
    usermod -aG docker "$(id -u -n)" || true
    systemctl enable --now docker
  else
    echo "Docker already installed."
  fi

  # === STEP 4: Create directory structure ===
  echo
  echo "=== Creating BladeMedia directories ==="
  mkdir -p \
    "$ROOT/media/movies" \
    "$ROOT/media/tv" \
    "$ROOT/downloads/incomplete" \
    "$ROOT/downloads/complete" \
    "$ROOT/downloads/jackett" \
    "$ROOT/tdarr_cache"

  # === STEP 5: Generate docker-compose.yml ===
  echo
  echo "=== Writing docker-compose.yml ==="
  cat > "$ROOT/docker-compose.yml" << 'EOF'
version: "3.9"

networks:
  media:
    driver: bridge

volumes:
  jellyfin_cache:
  jellyfin_config:
  jackett_config:
  rdtclient_config:
  bazarr_config:
  tdarr_config:
  tdarr_logs:
  tdarr_server_config:
  mediamanager_config:
  wizarr_config:

services:
  jellyfin:
    image: jellyfin/jellyfin:latest
    container_name: blademedia-jellyfin
    networks: [media]
    user: "0:0"
    environment:
      - TZ=Etc/UTC
    volumes:
      - jellyfin_config:/config
      - jellyfin_cache:/cache
      - ./media:/media
    ports:
      - "8096:8096"
    restart: unless-stopped

  jackett:
    image: lscr.io/linuxserver/jackett:latest
    container_name: blademedia-jackett
    networks: [media]
    environment:
      - PUID=0
      - PGID=0
      - TZ=Etc/UTC
    volumes:
      - jackett_config:/config
      - ./downloads/jackett:/downloads
    ports:
      - "9117:9117"
    restart: unless-stopped

  rdtclient:
    image: rogerfar/rdtclient:latest
    container_name: blademedia-rdtclient
    networks: [media]
    environment:
      - PUID=0
      - PGID=0
      - TZ=Etc/UTC
    volumes:
      - rdtclient_config:/data/db
      - ./downloads:/data/downloads
    ports:
      - "6500:6500"
    restart: unless-stopped

  flaresolverr:
    image: ghcr.io/flaresolverr/flaresolverr:latest
    container_name: blademedia-flaresolverr
    networks: [media]
    environment:
      - LOG_LEVEL=info
      - LOG_HTML=false
      - CAPTCHA_SOLVER=none
      - TZ=Etc/UTC
    ports:
      - "8191:8191"
    restart: unless-stopped

  bazarr:
    image: lscr.io/linuxserver/bazarr:latest
    container_name: blademedia-bazarr
    networks: [media]
    environment:
      - PUID=0
      - PGID=0
      - TZ=Etc/UTC
    volumes:
      - bazarr_config:/config
      - ./media:/media
    ports:
      - "6767:6767"
    restart: unless-stopped

  tdarr:
    image: ghcr.io/tdarr/tdarr:latest
    container_name: blademedia-tdarr
    networks: [media]
    environment:
      - PUID=0
      - PGID=0
      - TZ=Etc/UTC
      - serverIP=0.0.0.0
      - serverPort=8266
      - webUIPort=8265
    volumes:
      - tdarr_config:/app/configs
      - tdarr_logs:/app/logs
      - tdarr_server_config:/app/server
      - ./media:/media
      - ./tdarr_cache:/temp
    ports:
      - "8265:8265"
      - "8266:8266"
    restart: unless-stopped

  mediamanager:
    image: ghcr.io/maxdorninger/mediamanager:latest
    container_name: blademedia-mediamanager
    networks: [media]
    environment:
      - TZ=Etc/UTC
    volumes:
      - mediamanager_config:/app/data
      - ./media:/media
    ports:
      - "8787:8787"
    restart: unless-stopped

  wizarr:
    image: ghcr.io/wizarrrr/wizarr:latest
    container_name: blademedia-wizarr
    networks: [media]
    environment:
      - TZ=Etc/UTC
    volumes:
      - wizarr_config:/data
    ports:
      - "5690:5690"
    restart: unless-stopped
EOF

  # === STEP 6: Install Python + requests via apt (24.04-safe) ===
  echo
  echo "=== Installing Python + requests (apt) ==="
  apt update -y
  apt install -y python3 python3-requests

  # === STEP 7: Write media_organizer.py ===
  echo
  echo "=== Writing media_organizer.py ==="
  cat > "$ROOT/media_organizer.py" << 'EOF'
#!/usr/bin/env python3
"""
BladeMedia Organizer v2.1 - Ubuntu 24.04 friendly
Organizes movies and TV + optional Discord webhook summary.
"""

import os
import re
import shutil
import argparse
from datetime import datetime
from pathlib import Path
from typing import List, Tuple, Optional
import logging

import requests  # installed via python3-requests

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)


class MediaOrganizer:
    def __init__(self, root_path: str, dry_run: bool = False, discord_webhook: Optional[str] = None):
        self.root = Path(root_path)
        self.movies_root = self.root / "media" / "movies"
        self.tv_root = self.root / "media" / "tv"
        self.dry_run = dry_run
        self.discord_webhook = discord_webhook

        self.video_exts = {".mkv", ".mp4", ".avi", ".m4v", ".mov", ".wmv", ".flv"}
        self.subtitle_exts = {".srt", ".ass", ".ssa", ".sub", ".idx"}

        self.summary = {
            "movies_organized": 0,
            "movies_skipped": 0,
            "tv_organized": 0,
            "tv_skipped": 0,
        }

    # ---------- Discord ----------

    def send_discord(self, title: str, message: str, color: str = "success") -> None:
        if not self.discord_webhook:
            return

        colors = {"success": 0x00FF00, "warning": 0xFF9900, "error": 0xFF0000}
        embed = {
            "title": f"üé¨ {title}",
            "description": message,
            "color": colors.get(color, 0x00FF00),
            "timestamp": datetime.utcnow().isoformat(),
            "footer": {"text": "BladeMedia Organizer"},
        }

        try:
            requests.post(self.discord_webhook, json={"embeds": [embed]}, timeout=10)
        except Exception as e:
            logger.error("Discord send failed: %s", e)

    # ---------- Parsing helpers ----------

    def parse_movie_filename(self, filename: str) -> Optional[Tuple[str, int]]:
        patterns = [
            r"^(.+?)[. _-]+(?P<year>\d{4})[. _]",
            r"^(.+?)[. _]*\(?(?P<year>\d{4})\)?[. _]",
        ]
        filename = re.sub(r"[\[\]]", "", filename)
        for pattern in patterns:
            m = re.match(pattern, filename, re.IGNORECASE)
            if not m:
                continue
            title = (
                m.group(1)
                .strip(".- ")
                .replace(".", " ")
                .replace("_", " ")
                .strip()
            )
            year = int(m.group("year"))
            if 1900 <= year <= 2026:
                return title, year
        return None

    def parse_tv_filename(self, filename: str) -> Optional[Tuple[str, int, int, str]]:
        patterns = [
            r"^(?P<show>.+?)[. _]+S(?P<season>\d+)[. _]*E(?P<episode>\d+)(?:[._-].*)?(?P<title>.*)?[. _]",
            r"^(?P<show>.+?)[. _]+(?P<season>\d+)x(?P<episode>\d+)(?:[._-].*)?(?P<title>.*)?[. _]",
        ]
        filename = re.sub(r"[\[\]]", "", filename)
        for pattern in patterns:
            m = re.match(pattern, filename, re.IGNORECASE)
            if not m:
                continue
            show = (
                m.group("show")
                .strip(".- ")
                .replace(".", " ")
                .replace("_", " ")
                .strip()
            )
            season = int(m.group("season"))
            episode = int(m.group("episode"))
            title = m.group("title").strip(".- ") if m.group("title") else f"Episode {episode}"
            return show, season, episode, title
        return None

    # ---------- File helpers ----------

    def get_video_files(self, path: Path) -> List[Path]:
        files: List[Path] = []
        for ext in self.video_exts:
            files.extend(path.rglob(f"*{ext}"))
        return sorted(files)

    def find_associated_subs(self, video_path: Path) -> List[Path]:
        subs: List[Path] = []
        stem = video_path.stem
        for ext in self.subtitle_exts:
            subs.extend(video_path.parent.glob(f"{stem}*{ext}"))
        return sorted(subs)

    # ---------- Movie handling ----------

    def organize_movie(self, video_path: Path) -> None:
        parsed = self.parse_movie_filename(video_path.name)
        if not parsed:
            self.summary["movies_skipped"] += 1
            return

        title, year = parsed
        dest_folder = self.movies_root / f"[{title}] [{year}]"

        if dest_folder == video_path.parent:
            self.summary["movies_skipped"] += 1
            return

        logger.info("üìΩÔ∏è  [%s] [%s] <- %s", title, year, video_path.name)

        if not self.dry_run:
            dest_folder.mkdir(parents=True, exist_ok=True)
            shutil.move(str(video_path), str(dest_folder / video_path.name))
            for sub in self.find_associated_subs(video_path):
                if sub.exists():
                    shutil.move(str(sub), str(dest_folder / sub.name))

        self.summary["movies_organized"] += 1

    def run_movies(self) -> None:
        logger.info("üé¨ Scanning movies: %s", self.movies_root)
        videos = self.get_video_files(self.movies_root)
        logger.info("Found %d movie files", len(videos))
        for v in videos:
            self.organize_movie(v)

    # ---------- TV handling ----------

    def organize_tv(self, video_path: Path) -> None:
        parsed = self.parse_tv_filename(video_path.name)
        if not parsed:
            self.summary["tv_skipped"] += 1
            return

        show, season, episode, title = parsed
        show_year = 2025  # Placeholder until you add real metadata
        show_folder = self.tv_root / f"[{show}] [{show_year}]"
        season_folder = show_folder / f"Season {season} [{show_year}]"
        new_name = f"EP{episode} - {title} [{show_year}]{video_path.suffix}"
        dest_video = season_folder / new_name

        if season_folder == video_path.parent and video_path.name == new_name:
            self.summary["tv_skipped"] += 1
            return

        logger.info("üì∫ [%s] S%02dE%02d <- %s", show, season, episode, video_path.name)

        if not self.dry_run:
            season_folder.mkdir(parents=True, exist_ok=True)
            shutil.move(str(video_path), str(dest_video))
            for sub in self.find_associated_subs(video_path):
                if sub.exists():
                    new_sub = season_folder / f"{new_name.rsplit('.',1)[0]}{sub.suffix}"
                    shutil.move(str(sub), str(new_sub))

        self.summary["tv_organized"] += 1

    def run_tv(self) -> None:
        logger.info("üì∫ Scanning TV: %s", self.tv_root)
        videos = self.get_video_files(self.tv_root)
        logger.info("Found %d TV files", len(videos))
        for v in videos:
            self.organize_tv(v)

    # ---------- Main ----------

    def run(self) -> None:
        start = datetime.now()
        logger.info("BladeMedia Organizer starting at %s", self.root)
        self.run_movies()
        self.run_tv()
        elapsed = (datetime.now() - start).total_seconds()

        msg = (
            f"Movies: {self.summary['movies_organized']} organized, "
            f"{self.summary['movies_skipped']} skipped\n"
            f"TV: {self.summary['tv_organized']} organized, "
            f"{self.summary['tv_skipped']} skipped\n"
            f"Runtime: {elapsed:.0f}s"
        )

        total = self.summary["movies_organized"] + self.summary["tv_organized"]
        if total > 0:
            self.send_discord("‚úÖ Media Organized", msg, "success")
        else:
            self.send_discord("‚ÑπÔ∏è No Changes", "No new media to organize", "warning")

        logger.info("Done. %s", msg)


def main() -> None:
    parser = argparse.ArgumentParser(description="BladeMedia Media Organizer")
    parser.add_argument("root_path", nargs="?", default=".")
    parser.add_argument("--movies-only", action="store_true")
    parser.add_argument("--tv-only", action="store_true")
    parser.add_argument("--dry-run", action="store_true")
    parser.add_argument("--discord-webhook")
    args = parser.parse_args()

    organizer = MediaOrganizer(
        root_path=args.root_path,
        dry_run=args.dry_run,
        discord_webhook=args.discord_webhook,
    )

    if args.movies_only:
        organizer.run_movies()
    elif args.tv_only:
        organizer.run_tv()
    else:
        organizer.run()


if __name__ == "__main__":
    main()
EOF

  chmod +x "$ROOT/media_organizer.py"

  # === STEP 8: systemd units ===
  echo
  echo "=== Writing systemd units ==="

  # Docker stack service
  cat > /etc/systemd/system/blademedia.service << EOF
[Unit]
Description=BladeMedia Docker Stack
After=docker.service network-online.target
Requires=docker.service

[Service]
Type=oneshot
WorkingDirectory=${ROOT}
ExecStart=/usr/bin/docker compose up -d
ExecStop=/usr/bin/docker compose down
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF

  # Organizer service
  local ORG_ARGS=""
  if [[ -n "$WEBHOOK" ]]; then
    ORG_ARGS="--discord-webhook=${WEBHOOK}"
  fi

  cat > /etc/systemd/system/blademedia-organizer.service << EOF
[Unit]
Description=BladeMedia Media Organizer
After=blademedia.service network-online.target

[Service]
Type=oneshot
WorkingDirectory=${ROOT}
ExecStart=/usr/bin/python3 ${ROOT}/media_organizer.py . ${ORG_ARGS}
User=$(id -u)
Group=$(id -g)
StandardOutput=append:${ROOT}/organizer.log
StandardError=append:${ROOT}/organizer.log
TimeoutStartSec=300

[Install]
WantedBy=multi-user.target
EOF

  # Organizer timer
  cat > /etc/systemd/system/blademedia-organizer.timer << 'EOF'
[Unit]
Description=Run BladeMedia Organizer hourly
Requires=blademedia-organizer.service

[Timer]
OnCalendar=hourly
Persistent=true
RandomizedDelaySec=300

[Install]
WantedBy=timers.target
EOF

  # === STEP 9: enable + start ===
  echo
  echo "=== Enabling services and starting stack ==="
  systemctl daemon-reload
  systemctl enable blademedia.service blademedia-organizer.timer
  systemctl start blademedia.service
  systemctl start blademedia-organizer.timer

  # Quick dry-run test
  echo
  echo "=== Running organizer dry-run test ==="
  /usr/bin/python3 "$ROOT/media_organizer.py" . --dry-run || true

  echo
  echo "=============================================="
  echo " BladeMedia installation complete!"
  echo " Stack root: $ROOT"
  echo "----------------------------------------------"
  echo "Jellyfin:      http://<SERVER_IP>:8096"
  echo "MediaManager:  http://<SERVER_IP>:8787"
  echo "Wizarr:        http://<SERVER_IP>:5690"
  echo "Jackett:       http://<SERVER_IP>:9117"
  echo
  echo "Check services:"
  echo "  systemctl status blademedia.service"
  echo "  systemctl status blademedia-organizer.timer"
  echo
  echo "Logs:"
  echo "  docker compose logs -f      (in $ROOT)"
  echo "  tail -f $ROOT/organizer.log"
  echo "=============================================="
}

main "$@"
